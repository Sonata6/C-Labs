#include<stdio.h>
#include<conio.h>
#include<locale.h>
#include<windows.h>
#define kl 15
int main()
{
	setlocale(LC_ALL, "Russian");
	system("CLS");
	int ms[kl], N, i, j, m, nach = 0, kon = 0, k1 = 0, k2 = 1, kk = 0, k = 0; // ms-массив, N-максимальный элемент, i,j-счетчики, m-место хранения ячейки массива nach,kon-начало и конец части массива с одинаковым значением, k,k1,k2,kk - переменные, для работы с массивом
	printf("введите максимальное значение элемента массива:\n");
	scanf_s("%d", &N); //вводит максималное значение элемента массива
	printf("введите исходный массив\n");
	for (i = 0; i < kl; i++) //ввод массива
	{
		printf("ms[%d]:", i);
		if (!scanf_s("%d", &ms[i])) //умный ввод
			i--;
		rewind(stdin); // очистка буфера
		if (ms[i] > N) // условие записи в массив
			i--;
		if (ms[i] < 1)
			i--;
	}
	system("CLS");
	for (i = 0; i < kl - 1; i++) //сортировка пузырьком
		for (j = kl - 1; j > i; j--)
		{
			if (ms[j - 1] > ms[j])
			{
				m = ms[j - 1];
				ms[j - 1] = ms[j];
				ms[j] = m;
			}
		}
	system("CLS");
	do
	{
		k1 = 0;
		for (i = k; i < kl; i++) // определяет границы части массива, состоящей из максимального количества элементов
		{
			if (ms[i] == ms[i + 1]) // проверка на то, что следующий элемент массива равен предыдущему
				k2 += 1;
			else k2 = 1;
			if (k2 > k1)  // определяет границы
			{
				k1 = k2;
				kon = i + 1;
				nach = kon - k1 + 1; 
			}
		}
		kk = nach - 1;
		i = ms[nach];
		for (kk; kk > k-1; kk--) // записывает необходимое значение и освобождает нужное количество ячеек для переноса
			ms[kk + k1] = ms[kk];
		kk = k;
		for (kk; kk < k + k1; kk++) // переносит эти значения в начало массива
			ms[kk] = i;
		k += k1;
	} while (k < kl - 1);
	for (i = 0; i < kl; i++) //вывод отсортированного массива(не нужно)
		printf("ms[%d]:%d\n", i, ms[i]);
	system("pause");
	return 0;
}