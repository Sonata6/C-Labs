#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <dos.h>
#include <locale.h>
#include"Header.h"

tree* creat1(tree* dr, int r)
{
	static int i = 1;
	tree* dr1, * dr2;
	dr1 = (tree*)malloc(sizeof(tree));  // создание нового элемента(узла) добавляемого в дерево
	dr1->n = r;
	dr1->kl = i;
	i += 2;
	dr1->L = dr1->R = nullptr;
	if (!dr) return dr1; // если дерево пустое (dr==nullptr если в дерево еще не было ввода инф.)
	else                // иначе поиск места в дереве куда добавляется новый элемент
	{
		dr2 = dr;
		while (dr2)      // dr2-указатель "пробегает" по дереву до искомого узла или до конца ветви
		{
			if (dr1->n < dr2->n)  // dr1->n меньше dr2->n  
				if (dr2->L == nullptr)           // из вершины dr2 нет движения влево 
				{
					dr2->L = dr1;                 // вставка узла dr1 в дерево
					dr2 = nullptr;                // для выхода из цикла while
				}
				else dr2 = dr2->L;  // переход к следующей вершине дерева слева от dr2
			else                              // иначе: dr1->inf больше dr2->inf 
				if (dr2->R == nullptr)           // из вершины dr2 нет движения вправо 
				{
					dr2->R = dr1;                 // вставка узла dr1 в дерево
					dr2 = nullptr;                // для выхода из цикла while
				}
				else dr2 = dr2->R;  // переход к следующей вершине дерева справа от dr2
		}
	}
	return dr;
}

void show(tree* dr1)
{
	struct stack
	{
		tree* d;
		stack* s;
	} *st, * st1 = nullptr;

	if (!dr1) { printf("бинарное дерево пустое\n"); return; }
	int pr = 1;
	// в стек заносится элемент содержащий указа-
	st = (stack*)calloc(1, sizeof(stack)); // тель на корень дерева для прохода по
	st->d = dr1;                            // левому и правому поддеревьям
	st->s = st1;                            // указатель на предыдущий эл-т стека 
	printf("узел содержит : %d\n", dr1->n);
	while (st || dr1->R)  // пока стек не пустой и есть движение вправо по дереву
	{
		do  // цикл - пока не лист дерева
		{
			if (pr && dr1->L) dr1 = dr1->L;  // переход на узел слева
			else if (dr1->R) dr1 = dr1->R;   // переход на узел cправа
			pr = 1;                   // сброс принудительного движения вправо
			if (dr1->L && dr1->R)      // узел с 2 связями (вниз по дереву)
			{
				st1 = st;               // запоминаем вершину стека
				st = (stack*)calloc(1, sizeof(stack)); // новый эл-т стека
				st->d = dr1;            // указатель на найденый узел дерева
				st->s = st1;            // указатель из вершины стека на предыдущий 
			}
			printf("узел содержит :%d\n", dr1->n);
		} while (dr1->L || dr1->R);
		if (st)                      // стек не пустой
		{
			dr1 = st->d;             // возврат на узел ветвления в дереве
			st1 = st->s;             // в стеке адрес узла выше удаляемого
			free(st);                // удаление из стека указателя на выбранный узел
		}
		st = st1;                    // новая вершина стека
		if (dr1->L && dr1->R) pr = 0;   // это узел ветвления, устанавливаем признак принудительного 
		else break;                     // перехода на узел расположенный справа от dr1, т.к.
									 // dr1->inf уже выведен при проходе слева
	}
}


int* getms(tree* dr1, int i)
{
	struct stack
	{
		tree* d;
		stack* s;
	} *st, * st1 = nullptr;
	int* ms;
	int n = 0;
	ms = (int*)malloc(i * sizeof(int));
	if (!dr1) { printf("бинарное дерево пустое\n"); return 0; }
	int pr = 1;
	// в стек заносится элемент содержащий указа-
	st = (stack*)calloc(1, sizeof(stack)); // тель на корень дерева для прохода по
	st->d = dr1;                            // левому и правому поддеревьям
	st->s = st1;                            // указатель на предыдущий эл-т стека 
	ms[n++] = dr1->kl;
	while (st || dr1->R)  // пока стек не пустой и есть движение вправо по дереву
	{
		do  // цикл - пока не лист дерева
		{
			if (pr && dr1->L) dr1 = dr1->L;  // переход на узел слева
			else if (dr1->R) dr1 = dr1->R;   // переход на узел cправа
			pr = 1;                   // сброс принудительного движения вправо
			if (dr1->L && dr1->R)      // узел с 2 связями (вниз по дереву)
			{
				st1 = st;               // запоминаем вершину стека
				st = (stack*)calloc(1, sizeof(stack)); // новый эл-т стека
				st->d = dr1;            // указатель на найденый узел дерева
				st->s = st1;            // указатель из вершины стека на предыдущий 
			}
			ms[n++] = dr1->kl;
		} while (dr1->L || dr1->R);
		if (st)                      // стек не пустой
		{
			dr1 = st->d;             // возврат на узел ветвления в дереве
			st1 = st->s;             // в стеке адрес узла выше удаляемого
			free(st);                // удаление из стека указателя на выбранный узел
		}
		st = st1;                    // новая вершина стека
		if (dr1->L && dr1->R) pr = 0;   // это узел ветвления, устанавливаем признак принудительного 
		else break;                     // перехода на узел расположенный справа от dr1, т.к.
									 // dr1->inf уже выведен при проходе слева
	}
	Sort(ms, i);
	return ms;
}

void Sort(int* num, int size)      // сортировка выбором
{
	int min, temp; // для поиска минимального элемента и для обмена
	for (int i = 0; i < size - 1; i++)
	{
		min = i; // запоминаем индекс текущего элемента
		// ищем минимальный элемент чтобы поместить на место i-ого
		for (int j = i + 1; j < size; j++)  // для остальных элементов после i-ого
		{
			if (num[j] < num[min]) // если элемент меньше минимального,
				min = j;       // запоминаем его индекс в min
		}
		temp = num[i];      // меняем местами i-ый и минимальный элементы
		num[i] = num[min];
		num[min] = temp;
	}
}

